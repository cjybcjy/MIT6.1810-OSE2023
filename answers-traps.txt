1. Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?
a0-a7
The format string "%d %d\n" is passed as the first argument to printf.----->a0
The evaluated expression 12 is passed as the second argument.------->a1
The integer 13 is passed as the third argument.-------->a2


2. Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)
    none of both. 在 RISC-V 汇编中，函数调用通常使用 auipc 和 jalr 指令来跳转到目标函数
    g(x) is inlined within f(x), and f(x) is further inlined into main()

3. At what address is the function printf located?
    pc = ra + 1570 = 0x30 + 0x622 = 0x652   <printf>  main calls it with pc-relative addressing

4. What value is in the register ra just after the jalr to printf in main?
    返回地址 = 当前 PC + 4(指令长度)
    返回地址存储在 ra 寄存器中
    ra = 0x0000000000000038

5. Run the following code.
            unsigned int i = 0x00646c72;
            printf("H%x Wo%s", 57616, &i);   
   (1) What is the output? 
        %x will print the hexadecimal representation of the integer 57616
                                                             --->0xe110
        %s will print the string that starts at the memory address &i 
                                                        ---> 0x72 0x6c 0x64 0x00
                            This represents the string "rld" in memory when interpreted as a string starting from the least significant byte.
        The output is "He110 World"

   (2) The output depends on that fact that the RISC-V is little-endian. 
    If the RISC-V were instead big-endian what would you set i to in order to yield the same output? 
    Would you need to change 57616 to a different value?
        Little-endian:
            Memory: 0x72 0x6c 0x64 0x00
            Interpreted as: "rld"
        In a big-endian system, the bytes are stored from the most significant byte (MSB) to the least significant byte (LSB). 
        To get the same output ("rld") when interpreting i as a string, you need to reverse the byte order:
            Big-endian:
            Memory: 0x00 0x64 0x6c 0x72
            Interpreted as: "rld"

        The value 57616 is used with the %x format specifier, which simply prints it in hexadecimal form as e110. 
        Since this value doesn't depend on memory layout or endianness, you do not need to change 57616.


6. In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) 
    Why does this happen?   printf("x=%d y=%d", 3);
    A: The printf function expects a certain number of arguments based on the format string provided.
        , it expects two integers, but only one is supplied via a1. 
        When the function tries to access the second argument from a2, which could be any arbitrary value.
        The output after y= is unpredictable and demonstrates undefined behavior 
        due to the mismatch between the format string and the provided arguments. 